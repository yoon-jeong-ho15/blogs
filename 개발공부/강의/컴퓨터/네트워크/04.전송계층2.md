---
title: TCP (RDT)
index: 4
date: 2025-09-04
tags:
  - 네트워크
  - KOCW
---
# TCP 연결과 신뢰적 데이터 전송

## TCP 주요 특징

TCP 연결의 주요 특징들은 다음과 같다.

**point-to-point**: 발신자와 수신자는 고유의 소켓으로 연결되어있다.

**send & receive buffers**: 임시로 정보들을 보관하는 버퍼가 보낼 때와 받을 때 두 경우 다 필요하기 때문에 둘 다 가지고 있다.

**reliable in-order byte stream**: 손실 없이 reliable하고, 전송된 순서대로 in-order로 정확히 전달한다.

**pipelined**: 한 번에 여러 개의 패킷을 전송할 수 있다.

**full duplex data**: 한 연결에서 데이터가 양 방향으로 전송될 수 있다.

**flow control**: 발신자는 수신자가 처리할 수 있는 속도보다 빠르게 보내지 않는다.

## 계층별 데이터 전송 단위

응용계층에서 데이터 전송 단위는 *메시지*라고 한다 (이것도 헤더와 데이터 부분으로 이루어져 있다). 이 메시지가 소켓을 통해 TCP로 내려오면 *세그먼트* 안의 데이터 부분에 들어간다.

그리고 이 세그먼트는 네트워크 계층의 전송 단위인 *패킷*의 데이터 부분에 들어가고, 이 패킷은 다시 링크 계층의 전송 단위인 *프레임*의 데이터 부분에 들어간다.

각 계층에 대해 알아볼 때 데이터 부분이 아니라 사실 **헤더가 중요하다**. 헤더 부분에 해당 계층이 하는 처리 결과가 들어가게 되기 때문이다.

## TCP 세그먼트 구조

### 헤더 필드들

각 필드들은 전부 32비트 단위로 이루어져 있다.

```
Source Port (16bit)         | Destination Port (16bit)
Sequence number (32bit)
Acknowledgement number (32bit)
Data Offset (4bit) | Reserved (6bit) | Flags (6bit) | Window (16bit)
Checksum (16bit)            | Urgent Pointer (16bit)
```

위의 필드들이 한 줄마다 각각 32비트씩 혼자 혹은 나눠서 차지하고 있다.

### 시퀀스 번호와 ACK 번호

**시퀀스 번호 (Sequence Number)**

TCP에서 사용하는 시퀀스 번호는 **'데이터 부분의 제일 첫 바이트의 순서번호'** 다.

예를 들어 메시지 자체가 100바이트 크기라고 하자 (0부터 99번 바이트까지 있다). 한 번에 10바이트씩 전송을 할 수 있다고 하면:
- 첫 번째 전송: 시퀀스 번호 0 (0-9번 바이트)
- 두 번째 전송: 시퀀스 번호 10 (10-19번 바이트)
- 세 번째 전송: 시퀀스 번호 20 (20-29번 바이트)
- ...

**ACK 번호 (Acknowledgement Number)**

ACK 번호의 경우에는 정상적으로 받은 다음 바이트 번호가 된다. 위에서 0-9번 바이트를 전송했고 수신자가 이상없이 잘 받았다면 ACK 번호는 10번이 된다.

> **참고**: TCP 통신 중에는 양측 모두 상시 데이터를 주고받는 중이기 때문에, ACK 피드백을 보낼 때도 받는 즉시 보내지 않고 상대방에게 데이터를 전송할 일이 있을 수도 있으니 500ms 정도 기다렸다가 다른 세그먼트에 piggyback해서 보낸다거나, 전송할 데이터가 없으면 그냥 응답만 보낸다고 한다.

## 신뢰적 데이터 전송 (Reliable Data Transfer)

### 적응적 타임아웃 (Adaptive Timeout)

이전에 타이머에 대해서 간략하게 다뤘었다. 너무 빠르면 네트워크 사용량이 많아질 것이고, 너무 느리면 전송 과정 자체가 느려질 것이다. 그래서 적절한 타임아웃을 찾는 게 중요한데 다음과 같이 측정한다고 한다.

**RTT 추정 공식:**

```
EstimatedRTT = (1-α)*EstimatedRTT + α*SampleRTT    (typically, α = 0.125)
DevRTT = (1-β)*DevRTT + β*|SampleRTT-EstimatedRTT|  (typically, β = 0.25)
TimeoutInterval = EstimatedRTT + 4*DevRTT
```

한 번 전송된 세그먼트에 대한 응답시간인 SampleRTT를 기존 평균에 더해서 다시 평균값을 낸다 (그런데 그냥 1/n 평균이 아니라 최근 RTT에 큰 가중치를 주면서 평균을 낸다).

그리고 DevRTT (변동성)를 측정해서 여기에 4배의 마진을 붙여서 타임아웃 시간을 정한다. 즉 **통신 중에도 계속 타임아웃 값이 변한다**는 점이 중요하다.

### 빠른 재전송 (Fast Retransmit)

이전 시간에 RDT를 구현하는 프로토콜을 고안해봤다: Go-back-N 방식과 Selective Repeat. TCP는 기본적으로 GBN의 cumulative ACK를 사용한다.

**기존 GBN의 문제점:**
기존 GBN에서 단점은 중복된 세그먼트를 계속 받아야 한다는 것이었다. 예를 들어 100개의 세그먼트를 받았을 때 10번 세그먼트**만** 유실됐고, 그렇다는 피드백 ACK(9)를 전송하면 발신자는 10번부터 다시 100개의 세그먼트를 다시 전송한다. 그러면 11번부터 99번까지 90개 가량의 세그먼트를 재전송하는 네트워크가 낭비되는 셈이다.

**TCP의 Fast Retransmit 방식:**
그래서 TCP에서는 어떻게 하느냐면, 마찬가지로 10번 세그먼트만 유실됐다면:
1. 10번 세그먼트가 유실된 후 11번, 12번, ... 세그먼트가 계속 도착한다
2. 하지만 10번이 없기 때문에 계속해서 ACK(10)을 보낸다 (ACK(9)가 아니다)
3. 발신자 측에서는 0-99번 세그먼트를 보냈고 타임아웃 시간이 되기 전까지 계속해서 ACK(10)을 받게 된다
4. 그러면 나머지 세그먼트는 정상적으로 도착했다고 가정하고 10번 세그먼트**만** 다시 보낸다

**Fast Retransmit 규칙:** 권고사항에 따르면 중복된 ACK를 3번 받으면, 즉 원래 ACK까지 총 4개의 같은 응답을 받으면 해당 세그먼트만 재전송한다.

이런 방식을 *Fast Retransmit*이라고 한다. 이를 통해 타임아웃을 기다리지 않고도 빠르게 유실된 패킷을 재전송할 수 있어서 전송 효율성이 크게 향상된다.

## 정리

TCP는 이처럼 다양한 메커니즘을 통해 신뢰적이고 효율적인 데이터 전송을 보장한다:
- **적응적 타임아웃**: 네트워크 상황에 따라 동적으로 타임아웃 값을 조정
- **Fast Retransmit**: 중복 ACK를 통해 빠른 오류 복구
- **Cumulative ACK**: 순차적인 데이터 전달 보장

이러한 특징들이 결합되어 TCP가 인터넷에서 가장 널리 사용되는 전송 프로토콜이 될 수 있었던 것이다.

%% 
# 개요
TCP 연결의 주요 특징들로는 다음과 같은 것들이 있다.

**point-to-point** : 발신자와 수신자는 고유의 소켓으로 연결되어있다.
**send & receive buffers** : 임시로 정보들을 보관하는 버퍼가 보낼때와 받을 때 두 경우 다 필요하기 때문에 둘 다 가지고 있다.
**reliable in-order byte stream** : 손실 없이 reliable, 전송된 순서대로 in-order 정확히 전달한다.
**pipelined** : 한 번에 여러 개의 패킷을 전송할 수 있다.
**full duplex data** : 한 연결에서 데이터가 양 방향으로 전송될 수 있다.
**flow controlled** : 발신자는 수신자가 처리할 수 있는 속도보다 빠르게 보내지 않는다.

# TCP 세그먼트
응용계층에서 데이터 전송 단위는 **메시지(이것도 헤더와 데이터부분으로 이루어져있다)** 라고 한다.
이 메시지가 소켓을 통해 TCP로 내려오면 **세그먼트** 안에 데이터 부분에 들어간다.
그리고 이 세그먼트는 네트워크 계층의 전송 단위인 **패킷** 의 데이터 부분에 들어가고,
이 패킷은 다시 링크 계층의 전송 단위인 **프레임**의 데이터 부분에 들어간다.

각 계층에 대해 알아볼 때 데이터 부분이 아니라 사실 헤더가 중요하다.
헤더부분에 해당 계층이 하는 처리 결과가 들어가게 되기 때문에.

## 필드들
각 필드들은 전부 32비트로 이루어져 있다.

Source Port / Destination Port
Sequence number
Acknowledgement number
Data Offset, Reserved / Window
Checksum / Urgent Pointer
(위의 필드들이 한 줄마다 각각 32비트씩 혼자 혹은 나눠서 차지하고 있다.)

## Seq num & ACK num
TCP에서 사용하는 시퀀스 넘버는 **'데이터 부분의 제일 첫 바이트의 순서번호'** 라고 한다.
예를들어 메시지 자체가 100바이트 크기라고 하자. (0부터 99번 바이트까지 있다.)
예를 들어 한번에 10바이트씩 전송을 할 수 있다고 하면, 처음에 시퀀스 번호는 첫 바이트의 번호인 0번. 그 다음에는 10번이 되고 다음엔 20번, 30번, ....

ack 번호의 경우에는 정상적으로 받은 다음 바이트 번호가 된다.
위에서 0-9번 바이트를 전송했고 수신자가 이상없이 잘 받았다면 ack 번호는 10번이 된다.

> TCP 통신중에는 양 측 모두 상시 데이터를 주고받는 중이기 때문에, ACK 피드백을 보낼때도 받는 즉시 보내지 않고 상대방에게 데이터를 전송할 일이 있을수 도 있으니 500ms 정도 기다렸다가 다른 세그먼트에 보낸다거나, 전송할 데이터가 없으면 그냥 응답만 보낸다고 한다.

## Reliable Data Transfer

### 타임아웃
저번에 타이머에 대해서 간략하게 다뤘었다.
너무 빠르면 네트워크 사용량이 많아질 것이고, 너무 느리면 전송 과정 자체가 느려질 것이다.
그래서 적절한 타임아웃을 찾는게 중요한데 다음과 같이 측정한다고 한다.

`EstimatedRTT = (1-a)*EstimatedRTT + a*SampleRTT` (typically, a(alpha) = 0.125)
`DevRTT = (1-b)*DevRTT + b*|sampleRTT-EstimatedRTT|` (typically, b(beta) = 0.25)
`TimeoutInterval = EstimatedRTT + 4*DevRTT`

한번 전송된 세그먼트에 대한 응답시간인 SampleRTT를 기존 평균에 더해서 다시 평균값을 낸다음. (그런데 그냥 1/n 평균이 아니라 최근 rtt에 큰 가중치를 주면서 평균을 낸다.)
그리고 DevRTT (변동성)을 측정해서 여기에 4배의 마진을 붙여서 타임아웃 시간을 정한다.
즉 **통신중에도 계속 타임아웃 값이 변한다**는 점.

### Fast Retransmit
이전 시간에 RDT를 구현하는 프로토콜을 고안해봤다 : Go-back-N 방식과 Selective Repeat. 
TCP는 기본적으로 GBN의 culumative ack를 사용한다.
기존 GBN에서 단점은 중복된 세그먼트를 계속 받아야한다는 단점이 있었다.
무엇이냐면, 100개의 세그먼트 받았을때 10번 세그먼트**만** 유실됐고, 그렇다는 피드백 ack(9)를 전송하면 발신자는 10번부터 다시 100개의 세그먼트를 다시 전송한다. 그러면 11번 부터 99번까지 90개 가량의 세그먼트를 전송하는 네트워크가 낭비되는 샘.

그래서 TCP에서는 어떻게 하느냐면, 마찬가지로 10번 세그먼트만 유실됐다면, 10번부터 다시 보내달라는 피드백 ack(10)(ack(9)가 아니다)을 보내는것은 마찬가지인데, 도착하는 세그먼트마다 ack(10)을 보낸다. 그러면 발신자 측에서는 0-99번 세그먼트를 보냈고 타임아웃 시간이 되기 전까지 계속해서 ack(10)을 받게 되고, 그러면 나머지 세그먼트는 정상적으로 도착했다고 가정하고 10번 세그먼트**만** 다시 보낸다. (권고사항에 따르면 중복된 ack를 3번 받으면, 즉 본 ack까지 총 4개 같은 응답을 받으면 해당 세그먼트만 재전송 한다.)

이런 방식을 **Fast Retransmit**이라고 한다.
 %%