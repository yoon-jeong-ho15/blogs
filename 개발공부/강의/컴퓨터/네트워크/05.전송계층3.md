---
title: TCP (Flow Control)
index: 5
date: 2025-09-05
tags:
  - 네트워크
  - KOCW
  - TCP
---
# Flow Control
저번 시간에는 RDT(reliable data transfer)에 대해서 학습했다.
주요한 특징들로는 *cumulative ack*를 사용해서 특정 지퀀스 번호까지의 모든 데이터가 성공적으로 전달한다는점.
그리고 여기에 *fast retransmit* 방식을 사용해 타이머가 끝나기 전에 같은 ack가 4개 도착한다면 해당 세그먼트는 유실되었다고 판단하고 즉시 재전송 한다는 점.
그리고 타임아웃 값을 타이머를 통신이 있을때마다 동적으로 정한다는 점.

그리고 또 다른 주요한 특징으로는 *흐름 제어Flow control*가 있다.

> 여기서 복습 
> **TCP는 운영체제 커널**에 구현되어 있고, 운영체제에서 제공하는 소켓 API를 통해 프로세스가 소켓을 생성하고, 포트에 할당하면 TCP를 사용할 수 있게 된다.
> 그리고 네트워크의 각 계층은 상위 계층에게 서비스를 제공한다.

TCP가 받은 데이터를 언제 가져갈지는 프로세스의 재량이다. 프로세스가 `read()`를 해야 TCP층에서 수신 버퍼 안에 있는 데이터를 올려줄 수 있다.
만약에 `read()`를 자주 하지 않으면 버퍼에 계속해서 데이터가 쌓이게 된다. 만약에 버퍼가 꽉 찼는데 계속해서 세그먼트가 도착한다면 어차피 유실될것이니까, 수신자는 자신의 수신 버퍼에 남은 공간에 대한 정보를 보낸다. 이를 *수신 윈도우*라고 한다. (이전시간 헤더에 Window라고 되어있는 부분.
송신자는 피드백 헤더에 있는 수신 윈도우 크기만큼만 데이터를 보낸다. 즉 윈도우 사이즈는 수신자에 의해 정해진다.
송신자 측의 *시퀀스 번호*와 마찬가지로 *윈도우 사이즈*도 **수신자 측**에 의해 결정되는 것이다.

## 데드락 상황

TCP에서 세그먼트가 나가는 경우는 두 가지가 있다.
1. 프로세스에서 `write()`를 해서 송신 버퍼에서 보낼 세그먼트가 있을 때.
2. 보낼 데이터가 없더라도, 수신한 세그먼트에 대한 피드백을 보낼 때.

만약에 수신자 측에서 수신 버퍼가 포화상태라고 알린다면, 송신자는 세그먼트를 보내지 않고 기다릴것이다. 언제까지? 다음에 도착하는 세그먼트에서 업데이트된 수신 윈도우 상황을 확인할 때 까지. 
A와 B 사이에서 이런 상황이 발생했다고 하고, B는 A의 버퍼가 여유가 생길 때 까지 기다리고 있다. 그런데 A는 B측에서 전송되는 세그먼트가 없으니 보낼 응답이 없고, 그래서 A 프로세스가 B 프로세스에 보낼 데이터가 있으면 거기에 같이 보내야하는데 만약 A 프로세스가 보낼 데이터가 전혀 없다면?

### 윈도우 프로브 
이에 대한 해결책은 의외로 간단하다. 
B가 만약에 A로부터 수신 윈도우가 0이라는 소식을 받으면, 주기적으로 (TCP 헤더는 40바이트 정도 크기인데, 여기에 전송할 데이터의 첫 바이트만 담은) 41바이트의 작은 *윈도우 프로브 Window Probe* 세그먼트를 보낸다.  

## 세그먼트의 크기는?
생각해보면 세그먼트의 가능한 제일 큰게 좋을것이다. 그래야 최대한 적은 수의 세그먼트를 주고 받을것이고 tcp 통신에서 각 세그먼트마다 적지 않은 비용이 든다는 점에서 최대한 세그먼트의 수를 줄이는게 좋을것이다.
그런데 세그먼트의 크기를 마구 늘리면, 일단 한번 유실됐을때 다시 전송해야되는 데이터의 양이 같이 커지면서 재전송 부담이 증가한다는 단점이 있고, 그리고 만약에 프로세스가 `write()`하는 데이터의 양이 적으면 하염없이 기다려야 된다는 단점이 있다.

이런 문제를 해결하기 위해 만들어진 *Nagle 알고리즘*은 이 문제를 간단히 해결한다.




