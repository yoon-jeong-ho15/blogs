---
title: 힙
index: 17
date: 2025-09-03
tags:
  - 자료구조
  - KOCW
  - 우선순위큐
  - 힙
---
# 힙(Heap) 자료구조

## 개요
우선순위 큐를 구현하는 자료구조들을 비교 분석해보면, 균형 이진 검색 트리가 안정적이고 일관된 $O(\log n)$ 성능을 보여준다는 것을 확인했다. 하지만 **이진 힙(Binary Heap)** 은 특별한 장점을 가진다:

- **검색, 삽입, 삭제**: $O(\log n)$ 시간 복잡도
- **최소/최대값 접근**: $O(1)$ 시간 복잡도

이러한 특성으로 인해 실시간으로 최우선 순위 원소에 빈번하게 접근해야 하는 시스템에서 널리 활용된다.

## 힙의 정의와 속성

힙은 *완전 이진 트리(Complete Binary Tree)* 구조를 기반으로 하며, 다음 두 가지 핵심 속성을 만족해야 한다:

### 1. 힙 순서 속성 (Heap Order Property)
모든 노드는 자식 노드들과 특정한 순서 관계를 유지해야 한다:

- **최소 힙(Min Heap)**: 각 노드의 값 ≤ 자식 노드들의 값
- **최대 힙(Max Heap)**: 각 노드의 값 ≥ 자식 노드들의 값

### 2. 완전 이진 트리 구조 속성
트리의 높이를 $h$라 할 때, 모든 리프 노드들이 레벨 $h$ 또는 $h-1$에 위치해야 한다. 이는 트리가 **완전 이진 트리** 형태를 유지함을 의미한다.

## 배열 기반 구현

힙의 가장 큰 장점 중 하나는 **포인터 없이 배열만으로 효율적인 구현이 가능**하다는 것이다. 완전 이진 트리의 특성을 활용하여 각 레벨을 순차적으로 배열에 저장한다.

### 예시 구조
```
      17
  13        6
1    4   2    5
```

배열 표현: `[17, 13, 6, 1, 4, 2, 5]`

### 인덱스 관계식
노드 인덱스를 $i$라 할 때:
- **부모 노드**: $\lfloor\frac{i-1}{2}\rfloor$
- **왼쪽 자식**: $2i + 1$
- **오른쪽 자식**: $2i + 2$

#### 검증 예시
인덱스 2(값 6)인 노드의 관계:
- 부모: $\lfloor\frac{2-1}{2}\rfloor = 0$ → 노드 17 ✓
- 자식들: $2 \times 2 + 1 = 5$, $2 \times 2 + 2 = 6$ → 노드 2, 5 ✓

## 주요 연산 구현

### 삭제 연산 (Extract-Min/Max)
**Percolate Down(흘러내리기)** 알고리즘을 사용한다:

1. 루트 노드(최우선순위 원소) 제거
2. 마지막 리프 노드를 루트 위치로 이동
3. 힙 속성 복원을 위해 percolate down 수행:
   - 현재 노드와 자식 노드들 비교
   - 힙 조건에 위배되면 적절한 자식과 교환
   - 조건을 만족하거나 리프에 도달할 때까지 반복

**시간 복잡도**: $O(\log n)$

### 삽입 연산 (Insert)
반대로 **Percolate Up** 알고리즘을 사용한다:

1. 새 원소를 마지막 위치(완전 이진 트리 유지)에 삽입
2. 힙 속성 복원을 위해 percolate up 수행:
   - 현재 노드와 부모 노드 비교
   - 힙 조건에 위배되면 부모와 교환
   - 조건을 만족하거나 루트에 도달할 때까지 반복

**시간 복잡도**: $O(\log n)$

## 성능 분석

| 연산        | 시간 복잡도      | 설명           |
| --------- | ----------- | ------------ |
| 최소/최대값 조회 | $O(1)$      | 루트 노드 직접 접근  |
| 삽입        | $O(\log n)$ | 상향 침투 과정     |
| 삭제        | $O(\log n)$ | 하향 침투 과정     |
| 힙 생성      | $O(n)$      | Bottom-up 힙화 |

이러한 특성으로 인해 힙은 우선순위 큐, 힙 정렬, 그래프 알고리즘의 핵심 자료구조로 활용되고 있다.


%% 
# 힙Heap 이란?
저번 시간에 우선순위 큐를 자료구조별로 구현할 때의 장단점을 보았다.
특히 균형 이진 검색 트리로 구현한다면 가장 안정적이면서 빠른 $O(logn)$ 복잡도로 삽입과 삭제가 이루어지는 것을 보았다.
그런데 이진 힙을 통해 구현하면**검색, 삽입, 삭제**에는 $O(logn)$의 복잡도를 가지지만, **최소/최대 값 찾기**에는 $O(1)$의 복잡도를 가질 수 있다고 한다. (자주 현재 상황을 확인해야 하는 경우에 자주 사용될것이라는 걸 알 수 있다.)

## 힙의 속성
트리와 비슷하다. (몇 가지 속성을 가지는 트리이다.)
그리고 사용되는 거의 모든 힙은 이진 힙 binary heap이므로 이진 힙을 기준으로 살펴본다.

- 힙의 기본 요구사항은 노드의 값이 그 자식 노드  '이상' 혹은 '이하'여야 한다. (**힙 속성**)
	-  MIn Heap : 노드의 값이 자식 노드의 값보다 작거나 같아(이하)야만 한다.
	- Max Heap : 노드의 값이 자식 노드의 값보다 크거나 같아(이상)야만 한다.
- 트리의 높이 h가 있을때, 모든 리프 노드들이 h혹은 h-1 레벨에 있어야한다. (즉 '**완전complete 이진 트리**'여야 한다.)

# 구현
트리와 달리 **배열**을 사용해서, 즉 포인터 없이 인덱스만 사용해 구현할 수 있다.
루트부터 시작해서 각 레벨별로 순서대로 배열에 위치시킨다.
```
      17
  13        6
1    4   2    5
```
이걸 배열에 담으면 `[17, 13, 6, 1, 4, 2, 5]` 이 된다.

## 부모, 자식 노드 찾기
어떤 노드의 인덱스 i를 가지고 부모, 자식 노드의 인덱스를 찾을 수 있다.
부모 : `(i-1)/2`
자식 : `(i*2)+1, (i*2)+2`

6노드의 인덱스 2로 직접 구해보자.
`(2-1)/2=0`이므로 0번째 노드인 17이 부모가 맞고,
`(2*2)+1=5, (2*2)+2=6`이므로 5,6번째 노드인 2와 5가 자식이 맞다.

## 삭제
**Percolate Down(흘러내리기)** 방식이라고 부른다. 

모든 우선순위 힙은 루트 노드만 제거한다.
그리고 가장 마지막 노드를 루트 자리에 넣고. (힙 조건을 위배하게 된다.)
그 후에 percolate down 방식으로 힙으로 만들어준다.
루트 노드의 왼쪽과 오른쪽 자식을 비교한다.
조건에 맞지 않는 경우 부모와 해당 자식의 위치를 바꾼다.
그렇게 리프 노드까지 

## 삽입
거꾸로 percolate up 방식이라고 한다.
일단 맨 마지막 노드에 새로운 노드를 추가하고 부모와 비교해봐서 조건에 맞으면 그대로 넘어가지만,
조건에 맞지 않는 경우 계속 부모와 바꿔준다. 
%%