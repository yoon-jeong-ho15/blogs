---
title: 정렬
index: 21
date: 2025-09-08
tags:
  - 자료구조
  - KOCW
  - 정렬
---
# 분류
**비교 횟수**에 의해
- 비교에 기반한 정렬 알고리즘에서는 최선의 경우 $O(nlogn)$, 최악의 경우 $O(n^2)$.
교환Swap 횟수에 의해
**메모리 사용**에 의해
- 어떤 알고리즘은 제자리(in-place)에서 수행되므로 데이터를 임시적으로 저장할 보조 공간을 위해 O(1)이나 O(logn) 메모리가 필요하다.
재귀에 의해
안정성에 의해
**적응성Adaptability** 에 의해
- 어떤 알고리즘들은 *선정렬presortedness* 에 의해 복잡도가 바뀐다.

# 대표적인 정렬 알고리즘들
## 버블 정렬 Bubble Sort
```c
void BubbleSort(int arr[], int len) {
  int i, j, tmp;
  for (i = 0; i < len - 1; ++i) {
    for (j = 0; j < len - i - 1; ++j) {
      if (arr[j] > arr[j + 1]) {
        tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
      }
    }
  }
}
```

```c
void BubbleSort(int arr[],int len){
	int pass, i, temp, swappted = 1;
	for(pass=len-1;pass>=0 && swapped;pass--){
		swapped = 0;
		for(i=0;i<pass;i++){
			if(arr[i] > arr[i+1]){
				temp = arr[i];
				arr[i] = arr[i+1];
				arr[i+1] = temp;
				swapped = 1;
			}
		}
	}
}
```

아래의 버블 정렬은 **조기 종료 조건**을 추가해서 약간은 최적화 된 버전.

## 선택 정렬 Selection Sort

```c
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
      
        int min_idx = i;
        
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
              
                min_idx = j;
            }
        }
        
        int temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;
    }
}
```

버블정렬과 달리 *조기 종료 조건*을 추가할 수 없다. 

### 수업 외 내용
수업에서는 다루지 않았지만 궁금해서 생각해 본 것들이다.
#### vs 버블 정렬
버블 정렬에서는 조기 종료가 가능했던 이유는, 바로 옆의 원소들끼리 비교를 해서 둘의 자리를 바꾸는 방식으로 진행되는 알고리즘이기 때문이다.
i 순회마다 j 순회를 반복하는것은 똑같으나, 버블은 j 순회마다 여러번 인접한 두 요소의 순서를 바꾼다. **j 순회 때 한번도 교환이 이루어지지 않았다는것**은 이미 해당 배열이 정렬되었다는 것임을 알 수 있고, 이 조건(j 순회 때 교환이 이루어지지 않았음)에 해당하는 변수를 선언해 사용한다면 반복문의 조건에 추가하는 방식으로 조기 종료를 구현할 수 있는것이다. 
그러면 버블 정렬이 선택 정렬보다 무조건 우월한 정렬 알고리즘일까? 아니다. 왜냐하면 버블 정렬에서는 잦은 교환 연산이 이루어지기 때문이다. 

#### *조기 종료 조건*을 생각해볼 수 있을까?
```js
function selectionSort(arr) {
    for (let i = 0; i < arr.length; i++) {      
        let min_idx = i;
        let check = true;
        
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
            if(arr[j]>arr[j+1]){
	            check = false;
            }
        }
        
        if(min_idx === i && check){
	        break;
        }else{
	        let temp = arr[i];
	        arr[i] = arr[min_idx];
	        arr[min_idx] = temp;
        }
    }
}
```
`[5,3,1,7,9]`를 선택 정렬한다고 해보자.
위의 코드라면 첫 순회때 `[1,3,5,7,9]`가 되고 두 번째 순회때 3보다 작은 숫자는 없으니 `min_idx===i` 조건이 충족되고 j와 j+1을 비교하는 `check` 변수도 true로 남으니까 조기 종료를 할 수 있다.

그러니까 버블 정렬의 조기 종료 조건을 그대로 가져온 셈이다.
그러나 단점은 j 반복마다 `arr[j]>arr[j+1]`비교를 한다는 것인데. 이걸 2번 연산이라고 하고,
기존의 선택 정렬에서 i 반복마다 남은 배열에서 최솟값을 찾는 연산을 1번 연산이라고 하면,
기존의 선택 정렬은 1번 연산을 배열의 크기 만큼 수행하는것이고, 내 알고리즘은 1번 연산 + 2번 연산을 조기 종료 시점까지 반복하는것이다.
최약의 경우 그냥 비교 연산을 두배로 실행하게 되는 것.

> 어떤 경우들이 최악의 경우들일까?

## 삽입 정렬 Insertion Sort

```c
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}
```
장점 :
- 간단한 구현
- 작은 데이터에 효율적
- 적응적 : 입력 리스트가 이비 정렬되어있다면, 삽입 정렬은 d가 반번의 횟수일 때 O(n+d)의 시간이 걸린다.
- 온라인 : 삽입 정렬은 입력 리스트를 받으면서 정렬할 수 있다.

## 병합 정렬 Merge Sort

Divide-and-Conquere의 대표적인 예시.

```c
#include <stdio.h>
#include <stdlib.h>

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r){
    
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temp arrays
    int L[n1], R[n2];

    // Copy data to temp arrays L[] and R[]
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays back into arr[l..r
    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[],
    // if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[],
    // if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// l is for left index and r is right index of the
// sub-array of arr to be sorted
void mergeSort(int arr[], int l, int r){
    
    if (l < r) {
        int m = l + (r - l) / 2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

// Driver code
int main(){
    
    int arr[] = {38, 27, 43, 10};
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, arr_size - 1);
    int i;
    for (i = 0; i < arr_size; i++)
        printf("%d ", arr[i]);
    printf("\n");
    
    return 0;
}
```

## 힙 정렬 Heap Sort

```c
// To heapify a subtree rooted with node i
// which is an index in arr[].
void heapify(int arr[], int n, int i) {

    // Initialize largest as root
    int largest = i; 

    // left index = 2*i + 1
    int l = 2 * i + 1; 

    // right index = 2*i + 2
    int r = 2 * i + 2;

    // If left child is larger than root
    if (l < n && arr[l] > arr[largest]) {
        largest = l;
    }

    // If right child is larger than largest so far
    if (r < n && arr[r] > arr[largest]) {
        largest = r;
    }

    // If largest is not root
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(int arr[], int n) {

    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {

        // Move current root to end
        int temp = arr[0]; 
        arr[0] = arr[i];
        arr[i] = temp;

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// A utility function to print array of size n
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Driver's code
int main() {
    int arr[] = {9, 4, 3, 8, 10, 2, 5}; 
    int n = sizeof(arr) / sizeof(arr[0]);

    heapSort(arr, n);

    printf("Sorted array is \n");
    printArray(arr, n);
    return 0;
}
```

힙 정렬은 기본적으로 배열을 힙으로 만들고 거기서 다시 선택 정렬을 수행하는것이다.
오름차순 정렬을 할때는 max heap을 사용하고 내림차순 정렬을 할 때는 min heap을 사용하는데, 그 이유는 루트를 가지고 맨 뒤에 배치하기 때문이다. 

시간 복잡도는 $O(nlogn)$ 이다.
`heapSort()`는 두 부분으로 나뉘는데, 처음에 무작위 배열을 max heap으로 만드는 과정과 그 힙에 차례대로 정렬을 하는 과정.
앞의 과정이 $O(n)$ 이고 뒤의 과정이 $O(nlogn)$ 이다.
처음에 힙을 만드는 과정은 배열의 상태에 따라 다르지만 최대의 경우 거의 n에 근접하는 횟수로 연산이 이루어질 수 있으므로 O(n)이다. 
그리고 정렬 과정은, 각 노드 n개를 전무 logn이 걸리는 heapify를 해주기 때문이다.
(heapify자체는 logn이지만 위에서는 그 logn을 x번 반복했을 때 그 횟수가 n에 수렴한다.)
이 둘을 더하면 $O(n)+O(nlogn)=O(nlogn)$.

## 퀵 정렬 Quick Sort

