---
title: 통합테스트
index: 4
date: 2025-10-10
tags:
  - 테스트코드
  - 인프런
  - 통합테스트
  - zustand
---
# 통합 테스트란?

두 개 이상의 모듈이 연결된 상태를 검증.
모듈들이 상호 작용햐여 발생하는 상태를 검증.
그래서 실제 앱이 동작하는 비즈니스 로직에 가깝게 기능을 검증할 수 있다.

## 통합 테스트 항목

- 특정 상태를 기준으로 동작하는 컴포넌트 조합
- API와 함께 상호작용 하는 컴포넌트 조합
- 단순 UI 렌더링 및 간단한 로직을 실행하는 컴포넌트(단위 테스트를 하지 않았던)가 제대로 렌더링 되는지 한번에 검증

## 예시

수업 자료의 `ProductList`와 `ProductCard` 컴포넌트를 보자.

```jsx
const ProductCard = ({
  product,
  onClickAddCartButton,
  onClickPurchaseButton,
}) => {
 const navigate = useNavigate();

  if (!product) {
    return null;
  }

  const { title, images, price, category, id } = product;

  const handleClickItem = () => {
    navigate(pathToUrl(pageRoutes.productDetail, { productId: id }));
  };
  
  const handleClickAddCartButton = ev => {
    onClickAddCartButton(ev, product);
  };
  
  const handleClickPurchaseButton = ev => {
    onClickPurchaseButton(ev, product);
  };
  
  return (.....);
};
```

프로덕트 카드는 자신을 호출하는 프로덕트리스트 컴포넌트에서 전달받은 prop들(product 객체, 이벤트 핸들러들)을 그대로 사용한다.
그리고 이 prop들을 가져오고 정의하는 곳은 프로덕트리스트 컴포넌트다.

```jsx
const ProductList = ({ limit = PRODUCT_PAGE_LIMIT }) => {
	...
	...
	
	const products =
    data?.pages.reduce((acc, cur) => [...acc, ...cur.products], []) ?? [];

  const handleClickCart = (ev, product) => {
    ev.stopPropagation();
    if (isLogin) {
      addCartItem(product, user.id, 1);
      toast.success(`${product.title} 장바구니 추가 완료!`, { id: TOAST_ID });
    } else {
      navigate(pageRoutes.login);
    }
  };
  
  const handleClickPurchase = (ev, product) => {
    ev.stopPropagation();
    if (isLogin) {
      addCartItem(product, user.id, 1);
      navigate(pageRoutes.cart);
    } else {
      navigate(pageRoutes.login);
    }
  };
	return (
	    <Grid container spacing={1} rowSpacing={1} justifyContent="center">
	      {products.map((product, index) => (
	        <ProductCard
	          key={`${product.id}_${index}`}
	          product={product}
	          onClickAddCartButton={handleClickCart}
	          onClickPurchaseButton={handleClickPurchase}
	        />
			))}
		...
		...
	);
};
```

먼저 `ProductCard`를 *단위테스트* 했을 때 검증할 수 있는 항목들은 다음과 같다 :
1. **prop 기준**으로 제품 정보가(price, name ..) 제대로 렌더링 되는지
2. 상품을 클릭 했을 때(`handleClickItem`) navigate 모킹을 통해 상세화면으로 이동하는지
3. 장바구니, 구매 버튼을 눌렀을 때 spy 함수를 통해 각 핸들러가 **호출**되는지
	- 호출이 되는지는 검증할 수 있지만 작동하는지 검증할 수 없다.

반면 `ProductList`를 *통합테스트* 했을 때 검증할 수 있는 항목들은 다음과 같다 :
1. 상품 리스트 조회 api에 맞게 상품 정보가 제대로 렌더링 되는지
2. 상품을 클릭 했을 때 navigate 모킹을 통해 상세화면으로 이동하는지
3. 장바구니 혹은 구매 버튼을 눌렀을 때 다음과같이 작동 하는지
	- 로그인 : 상품 추가 후 장바구니로 이동
	- 비로그인 : 로그인 페이지로 이동
4. 상품 리스트가 더 있는 경우 show more 버튼이 노출되고, 이를 통해 데이터를 더 가져올 수 있는지

위의 두 항목들을 비교해보면 1,2,3번은 **중복**된다고 볼 수 있다. (통1,2,3 이 성공한다는것은 단1,2,3 이 성공함을 **함의**한다) 그래서 프로덕트 카드에 대한 단위테스트를 하지 않고 프로덕트리스트의 통합테스트에서 한번에 검증하는것이 더 효과적이다.

# 통합 테스트 대상 선정하기

단위 테스트는 의존성이 적거나 없는 단순한 컴포넌트를 대상으로 한다.
그러나 통합 테스트는 API, 상태 관리 스토어, 리액트 컨텍스트 등 다양한 요소들이 결합된 컴포넌트가 특정 비즈니스 로직을 올바르게 수행하는지 검증. (즉 컴포넌트같의 상호작용, api 호출 및 상태 변경에 따른 UI 변경 사항 검증)

예제속 **메인 페이지**의 *비즈니스 로직*들로는 다음과 같은것들이 있다 :
- 네비게이션 영역의 로그인 여부에 따른 동작
- api를 통해 필터의 카테고리 데이터를 올바르게 렌더링 하는지
- 필터 항목을 수정했을 때 올바르게 반영되는지
- api 응답에 따라 상품 리스트가 적절하게 렌더링 되는지
- 등등

비즈니스 로직 : 
- 프로그램의 핵심 기능을 구현하는 코드
- 즉 사용자가 원하는 결과를 얻기 위한 계산, 처리, 의사 결정을 수행하는 코드

좋은 통합 테스트는 비즈니스 로직을 도메인 단위로 잘 나누어 수행되어야 한다. 
메인 페이지의 비즈니스 로직들은 다음과 같이 분류될 수 있다.
- 네비게이션 바 영역
	- 로그인 여부에 따른 UI 렌더링(장바구니)과 상호작용(로그인, 로그아웃)
- 상품 검색 영역
	- 필터 설정에 따른 검색 조건 설정 
- 상품 리스트 영역
	- 검색 결과에 따른 상품 리스트 렌더링과 버튼 클릭 상호작용(장바구니 추가, 자세히 보기)

만약에 상품 검색 영역에서 검색 필터에 새로운 필드를 추가하거나 하는등의 변경사항이 있거나, 상품 리스트에서 보여주는 상품의 정보가 변경되거나, 스크롤 로딩 방식에서 페이징 방식으로 변경하는 등의 각 도메인에서의 변경사항이 있어도 해당 도메인의 테스트 코드만 변경하면 된다.

즉 다음과 같이 테스트를 설계하면 된다.
1. 메인 페이지를 이루는 모든 요소들을 나열하고, 그 요소들을 도메인 단위로 묶어서 상위 컴포넌트를 만든다.
	- 페이지(`page.tsx`) -> 상위 컴포넌트(`ProductList.tsx`)-> 하위 컴포넌트(버튼, 상품정보 등 렌더링 되는 ui 요소)
2. 그리고 그 상위 컴포넌트에서 자식 컴포넌트들의 상태 관리나 api 호출을 응집시킨다.
3. 통합 테스트는 위의 상위 컴포넌트 단위로 수행한다.

# 상태 관리 모킹하기

상태 : 시간에 따라 변할 수 있는 데이터. 프론트에서 특히 '상태'가 중요하게 다뤄지는 이유는 UI가 상태에 직접적으로 의존하기 때문이다. 


# 통합 테스트 작성하기 - 상태 관리 모킹

# msw로 API 모킹하기
# RTL 비동기 유틸 함수를 통한 노출 테스트 작성

